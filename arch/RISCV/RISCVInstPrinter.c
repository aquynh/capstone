//===-- RISCVInstPrinter.cpp - Convert RISCV MCInst to asm syntax ---------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This class prints an RISCV MCInst to a .s file.
//
//===----------------------------------------------------------------------===//

#ifdef CAPSTONE_HAS_RISCV

#include <stdio.h>	// DEBUG
#include <stdlib.h>
#include <string.h>
#include <platform.h>

#include "RISCVInstPrinter.h"
#include "RISCVBaseInfo.h"
#include "../../MCInst.h"
#include "../../SStream.h"
#include "../../MCRegisterInfo.h"
#include "../../utils.h"
#include "RISCVMapping.h"

//#include "RISCVDisassembler.h"

//TODO_rod: Verify for the constant RISCV_ABIRegAltName, if I need to include RISCVGenRegisterInfo.inc. and define the macro GET_REGINFO_ENUM
#define GET_REGINFO_ENUM
#include "RISCVGenRegisterInfo.inc"

static void printRegName(SStream *OS, unsigned RegNo);
static void printOperand(MCInst *MI, unsigned OpNo, SStream *O);

// Autogenerated by tblgen.
static void printInstruction(MCInst *MI, SStream *O, MCRegisterInfo *MRI);
static bool printAliasInstr(MCInst *MI, SStream *OS, void *info);
static void printCustomAliasOperand(MCInst *MI, unsigned OpIdx,
  								unsigned PrintMethodIdx, SStream *OS);
static const char *getRegisterName(unsigned RegNo,
                                     unsigned AltIdx = RISCV_ABIRegAltName);

// Include the auto-generated portion of the assembly writer.
#define PRINT_ALIAS_INSTR
#include "RISCVGenAsmWriter.inc"

//void RISCVInstPrinter::printInst(const MCInst *MI, raw_ostream &O,
//                                 StringRef Annot, const MCSubtargetInfo &STI) 
void RISCV_printInst(MCInst *MI, SStream *O, void *info)
{
  MCRegisterInfo *MRI = (MCRegisterInfo *)Info;
  
  if (!printAliasInstr(MI, O))
	  printInstruction(MI, O, MRI);
  //printAnnotation(O, Annot);
}

static void printRegName(SStream *OS, unsigned RegNo)
{
	SStream_concat0(OS, getRegisterName(RegNo));
}


//void RISCVInstPrinter::printOperand(const MCInst *MI, unsigned OpNo,
//                                  raw_ostream &O, const char *Modifier) 
static void printOperand(MCInst *MI, unsigned OpNo, SStream *O)
{
  unsigned reg;
  MCOperand *MO = MCInst_getOperand(MI, OpNo);

	
	//TODO_rod: For each IF, other archs are calling some functions like MI->flat_insn->detail->arm.operands[MI->flat_insn->detail->arm.op_count].mem.disp = imm;. Need to investigate this, and also the call here to MO.getExpr()->print(O, &MAI);
  if (MCOperand_isReg(MO)) {
	reg = MCOperand_getReg(MO);
	printRegName(O, reg);  
    return;
  }

  if (MCOperand_isImm(MO)) {
	//TODO_rod: Confirm: Depending on the type of Imm, Different archs call SStream_concat in a different way. Verify if this way is correct.
	int64_t Imm = MCOperand_getImm(MO);
	if (Imm >= 0) {
		if (Imm > HEX_THRESHOLD)
			SStream_concat(O, "0x%"PRIx64, Imm);
		else
			SStream_concat(O, "%"PRIu64, Imm);
	} else {
		if (Imm < -HEX_THRESHOLD)
			SStream_concat(O, "-0x%"PRIx64, -Imm);
		else
			SStream_concat(O, "-%"PRIu64, -Imm);
	}
    return;
  }

  assert(MO.isExpr() && "Unknown operand kind in printOperand");
  MO.getExpr()->print(O, &MAI);
}

void RISCVInstPrinter::printFenceArg(const MCInst *MI, unsigned OpNo,
                                     raw_ostream &O) {
  unsigned FenceArg = MI->getOperand(OpNo).getImm();
  if ((FenceArg & RISCVFenceField::I) != 0)
    O << 'i';
  if ((FenceArg & RISCVFenceField::O) != 0)
    O << 'o';
  if ((FenceArg & RISCVFenceField::R) != 0)
    O << 'r';
  if ((FenceArg & RISCVFenceField::W) != 0)
    O << 'w';
}

void RISCVInstPrinter::printFRMArg(const MCInst *MI, unsigned OpNo,
                                   raw_ostream &O) {
  auto FRMArg =
      static_cast<RISCVFPRndMode::RoundingMode>(MI->getOperand(OpNo).getImm());
  O << RISCVFPRndMode::roundingModeToString(FRMArg);
}

#endif // CAPSTONE_HAS_RISCV