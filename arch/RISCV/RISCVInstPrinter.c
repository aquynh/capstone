//===-- RISCVInstPrinter.cpp - Convert RISCV MCInst to asm syntax ---------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This class prints an RISCV MCInst to a .s file.
//
//===----------------------------------------------------------------------===//

#ifdef CAPSTONE_HAS_RISCV

#include <stdio.h>	// DEBUG
#include <stdlib.h>
#include <string.h>
#include <platform.h>

#include "RISCVInstPrinter.h"
#include "RISCVBaseInfo.h"
#include "../../MCInst.h"
#include "../../SStream.h"
#include "../../MCRegisterInfo.h"
#include "../../utils.h"
#include "RISCVMapping.h"

//#include "RISCVDisassembler.h"

//TODO_rod: Verify for the constant RISCV_ABIRegAltName, if I need to include RISCVGenRegisterInfo.inc. and define the macro GET_REGINFO_ENUM
#define GET_REGINFO_ENUM
#include "RISCVGenRegisterInfo.inc"

static void printRegName(SStream *OS, unsigned RegNo);
static void printOperand(MCInst *MI, unsigned OpNo, SStream *O);
static void printFenceArg(MCInst *MI, unsigned OpNo, SStream *O);

// Autogenerated by tblgen.
static void printInstruction(MCInst *MI, SStream *O, MCRegisterInfo *MRI);
static bool printAliasInstr(MCInst *MI, SStream *OS, void *info);
static void printCustomAliasOperand(MCInst *MI, unsigned OpIdx,
  								unsigned PrintMethodIdx, SStream *OS);
static const char *getRegisterName(unsigned RegNo,
                                     unsigned AltIdx = RISCV_ABIRegAltName);

// Include the auto-generated portion of the assembly writer.
#define PRINT_ALIAS_INSTR
#include "RISCVGenAsmWriter.inc"

//Todo_rod: THis function only needed to fix manually special instructions. Maybe not needed.
void RISCV_post_printer(csh ud, cs_insn *insn, char *insn_asm, MCInst *mci)
{
	/*
	   if (((cs_struct *)ud)->detail != CS_OPT_ON)
	   return;
	 */
}

//void RISCVInstPrinter::printInst(const MCInst *MI, raw_ostream &O,
//                                 StringRef Annot, const MCSubtargetInfo &STI) 
void RISCV_printInst(MCInst *MI, SStream *O, void *info)
{
  MCRegisterInfo *MRI = (MCRegisterInfo *)Info;
  
  if (!printAliasInstr(MI, O))
	  printInstruction(MI, O, MRI);
  //printAnnotation(O, Annot);
}

static void printRegName(SStream *OS, unsigned RegNo)
{
	SStream_concat0(OS, getRegisterName(RegNo));
}


//void RISCVInstPrinter::printOperand(const MCInst *MI, unsigned OpNo,
//                                  raw_ostream &O, const char *Modifier) 
static void printOperand(MCInst *MI, unsigned OpNo, SStream *O)
{
  unsigned reg;
  //TODO_rod: test if this check is needed:
	//if (OpNo >= MI->size)
		//return;	
  MCOperand *MO = MCInst_getOperand(MI, OpNo);

  if (MCOperand_isReg(MO)) {
	reg = MCOperand_getReg(MO);
	printRegName(O, reg);  	  
	//TODO_rod: Other archs check also for "if (MI->csh->doing_mem)". Tricore is not. Verify if it is needed. **cs_riscv riscv should be defined in capstone.h
	  //Sparc and tricore use this function "reg = Sparc_map_register(reg);" from SparcMapping.c - Check if it is needed or if the reg obtained before matches.
	if (MI->csh->detail) {
			MI->flat_insn->detail->riscv.operands[MI->flat_insn->detail->riscv.op_count].type = RISCV_OP_REG;
			MI->flat_insn->detail->riscv.operands[MI->flat_insn->detail->riscv.op_count].reg = reg;
			MI->flat_insn->detail->riscv.op_count++;
	}
	  
    return;
  }

  if (MCOperand_isImm(MO)) {
	//TODO_rod: Confirm: Depending on the type of Imm, Different archs call SStream_concat in a different way. Verify if this way is correct.
	int64_t Imm = MCOperand_getImm(MO);
	if (Imm >= 0) {
		if (Imm > HEX_THRESHOLD)
			SStream_concat(O, "0x%"PRIx64, Imm);
		else
			SStream_concat(O, "%"PRIu64, Imm);
	} else {
		if (Imm < -HEX_THRESHOLD)
			SStream_concat(O, "-0x%"PRIx64, -Imm);
		else
			SStream_concat(O, "-%"PRIu64, -Imm);
	}
	  
	if (MI->csh->detail) {
			MI->flat_insn->detail->riscv.operands[MI->flat_insn->detail->riscv.op_count].type = RISCV_OP_IMM;
			MI->flat_insn->detail->riscv.operands[MI->flat_insn->detail->riscv.op_count].imm = Imm;
			MI->flat_insn->detail->riscv.op_count++;
	}
    return;
  }
  //MO.getExpr()->print(O, &MAI);
}

static void printFenceArg(MCInst *MI, unsigned OpNo,
                                     raw_ostream &O) {
  MCOperand *MO = MCInst_getOperand(MI, OpNo);	
  unsigned FenceArg = MCOperand_getImm(MO);
	
  if ((FenceArg & RISCVFenceField_I) != 0)
	SStream_concat0(O, "i");
  if ((FenceArg & RISCVFenceField_O) != 0)
    SStream_concat0(O, "o");
  if ((FenceArg & RISCVFenceField_R) != 0)
    SStream_concat0(O, "r");
  if ((FenceArg & RISCVFenceField_W) != 0)
    SStream_concat0(O, "w");
}

//TODO_rod: So far I am not including this functions unless it is really needed.
/*void RISCVInstPrinter::printFRMArg(const MCInst *MI, unsigned OpNo,
                                   raw_ostream &O) {
  auto FRMArg =
      static_cast<RISCVFPRndMode::RoundingMode>(MI->getOperand(OpNo).getImm());
  O << RISCVFPRndMode::roundingModeToString(FRMArg);
}*/

#endif // CAPSTONE_HAS_RISCV